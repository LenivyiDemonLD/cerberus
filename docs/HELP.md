# Справочные материалы

## Репозиторий (Repository)
Хранилище проекта.  
Содержит весь код, историю изменений и ветки.  
У нас один общий репозиторий: `college-core`.   
Такие общие репозитории называются *монорепозиториями*.
Приставка *моно-* означает один, единый.

## Клонирование (Clone)
Создание локальной копии репозитория на своём компьютере.  
```bash
git clone <ссылка>
```

## Коммит (Commit)
Коммит — это внесение или фиксация изменений.   
Поясняющее сообщение (Commit message) — это комментарий, кратко описывающий твои изменения.     
Создание коммита:
```bash
git add .
git commit -m "Commit message"
```

Пиши коротко и по делу:
- Добавил экран отчёта — ХОРОШО

- Реализован контроллер посещаемости — ХОРОШО
  
- починил кое-что — ПЛОХО

- пофиксил фигню — ПЛОХО

Если ты совершишь ошибку и захочешь откатиться, то ты потом скажешь себе спасибо за то, что ты адекватным образом описывал собственные действия.

## Ветка (Branch)
Изолированная линия разработки.     
Позволяет работать над своей частью проекта, не ломая чужой код.    
`main` — это основная ветка.    
Все остальные (`backend`, `desktop`, `mobile`, `web`) — рабочие.    
Создание ветки:
```bash
git checkout -b имя_ветки
```
Переключение на уже существующую ветку:
```bash
git checkout имя_ветки
```
На самом деле есть ещё `git switch` для переключения и `git switch -c` для создания новой, но нам оно не надо.

## Feature
Одно законченное изменение в проекте, которое добавляет или улучшает что-то.

Примеры фич:

- экран авторизации;

- форма отчёта;

- эндпоинт /api/attendance;

- загрузка данных из БД;

- переключатель темы.

То есть фича — это атомарная часть логики, которая сама по себе работает, но не ломает остальное.

Я крайне рекомендую выделять под отдельную фичу отдельную ветку, потому что так будет проще тебе как разработчику.  
Если ты в процессе написания одной фичи решил сделать другую, то напиши себе комментарий
```Java
//TODO: сделать вот это потом
```
и продолжи делать предыдущую, закончи её, сделай PR и только тогда приступай к новой фиче.  

### Почему для каждой фичи нужна отдельная ветка

#### Изоляция.
Ты можешь спокойно писать свою часть, не мешая другим.
Если что-то сломал — не поломал весь проект.

#### Контроль.
Любое изменение можно просмотреть отдельно, понять, кто и зачем его сделал.
Легче проверять и ревьюить код.

#### Чистая история.
В `main` попадают только законченные и проверенные фичи, без мусора и черновиков.

#### Параллельная работа.
Один пишет фичу `login`, другой — `report-view`, третий — `api-attendance`.
Никто никого не блокирует.

#### Без паники при ошибках.
Если твоя фича оказалась неудачной — просто удаляешь ветку.
Основной проект (`main`) при этом не тронут.

Так будет проще тебе самому.
## Push
Отправка своих коммитов на GitHub.
```bash
git push origin имя_ветки
```

## Pull
Загрузка свежих изменений из GitHub в свой локальный проект.
```bash
git pull origin main
```

## Pull Request (PR)
Запрос на слияние веток. В нашем случае запрос на слияние ветки, в которой ты работал, с основной веткой `main`.

### Инструкция
1. Зайди на `GitHub`.
2. Нажми сверху `Pull requests`.
3. Справа сверху нажми `New pull request`.
4. В блоке `Compare changes` нажми на выпадающий список `compare: main` и выбери свою ветку
5. Назови PR осмысленно, обязательно укажи над каким компонентом ты работал:
    ```
    [Backend] Реализован эндпоинт для отметки посещаемости
    [Desktop] Добавлена форма отчёта
    [Mobile] Добавлен экран авторизации
    [Web] Добавлен макет главной страницы
    ```
6. Я волью изменения в основную ветку `main`.

## Merge 
Слияние веток.  
Обычно делается автоматически, когда PR принимают.  
Если есть конфликты — решаются вручную. 

## Конфликт (Merge Conflict)
Ситуация, когда два человека изменили одну и ту же строку в коде.   
Git не знает, чьё изменение оставить, и просит решить вручную.  
Именно из-за этого я не рекомендую лезть в чужие папки. 

## .gitignore
Файл, где перечислены папки и файлы, которые не должны попадать в репозиторий
(например, `node_modules`, `bin`, `obj`, `build`, `target` и т.д.).

## Remote
Указатель на удалённый репозиторий (например, GitHub).
Обычно называется `origin`.

## Stage (или index)
Промежуточная зона, куда добавляют файлы перед коммитом.

```bash
git add .
```

## Diff
Показывает различия между версиями файлов.
```bash
git diff
```

## Revert
Откат конкретного коммита.
```bash
git revert <commit-id>
```

## Reset
Полный откат ветки на нужный коммит (осторожно, ты потеряешь свои изменения!).
```bash
git reset --hard <commit-id>
```

## Fetch
Получение последних изменений без автоматического слияния.
```bash
git fetch origin
```

## Docker
Инструмент для запуска приложений в контейнерах, чтобы все могли запускать проект одинаково на разных компьютерах, иначе нам придётся постоянно держать поднятым сервер и настраивать CI/CD.

```bash
docker compose up -d
```

## CI/CD (Continuous Integration / Continuous Deployment)
**Continuous Integration** — непрерывная интеграция, автоматический процесс сборки и тестирования всего проекта. Для этого нужно писать тесты, но если мы их напишем, то нам не придётся проверять руками правильно ли взаимодействуют наши приложения между собой или нет.

**Continuous Deployment** — непрерывное развертывание, автоматическая доставка изменений на сервер для работы, как только они пройдут стадию тестов. Учитывая, что сервер не будет запущен 24/7, оно нам не надо. Я добавил это, потому что эти термины часто идут вместе.

В нашем случае вполне реально реализовать первую стадию — Continuous Integration — только лишь инструментами GitHub. Это позволит нам не тестировать руками то, как общаются приложения, но, в целом, мы легко можем и обойтись без этого.

## README.md
Главный файл проекта с описанием, целями, структурой и инструкциями по запуску.

## LICENSE
Файл с юридическим разрешением использовать, изменять и распространять проект.  

По приколу добавил.

## CONTRIBUTING.md
Файл с инструкцией, как участвовать в разработке проекта.

## docs/
Папка с документацией — планами, схемами, описаниями, справочниками.

## P.S.
Естественно, все упомянутые действия можно делать через твою среду разработки (Visual Studio, Android Studio, Visual Studio Code, IntellijIdea, WebStorm). Я описал их тут в виде команд, потому что это универсально сразу для всех и не зависит от среды.